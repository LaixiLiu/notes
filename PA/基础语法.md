### 变量与可变性
#### 变量
Rust使用let声明一个默认不可变的变量:
```Rust
fn main() {
	let x = 5;
	println!("The value of x is :{x}");
}
```
如果要声明可变变量，则需在变量名称前加上`mut`关键字，意为可变的(mutable):
```Rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
#### 常量
使用Rust中的常量时需要注意以下几点：
1. 不允许对常量使用`mut`；
2. 使用`const`声明常量时，必须注明值的类型；
3. 常量的值只能被设置为一个常量表达式，不能是一个只能在运行时才能被计算的值;
4. 常量的命名必须为单词之间使用全大写加下划线，如"HELLO_WORLD"，若不满足该格式，则在编译阶段会报warning；
```Rust
fn main() {
    const HELLO_NUM: u16 = 111;
    println!("The value of HELLO_NUM is {HELLO_NUM}");
}
```

常量在其作用域内，在整个程序的生命周期都有效。

#### 隐藏(Shadowing)
使用`let`声明的不可变变量，可以利用`Shadowing`机制定义一个与之前名称相同的新变量，这个新变量的作用域与其声明的位置有关，如：
```Rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```
```
The value of x in the inner scope is: 12
The value of x is: 6
```
`x`的值首先声明为5,接下来又声明为`x+1`，即6；在下一个`{}`作用域内，`x`的值又被声明为`x*2`，即12；当`let x = x * 2`所重新声明的`x`的作用域结束时，x的值恢复为6。

`Shadowing`与`mut`的区别在于：`mut`所声明的变量，其类型不能被改变；而`Shadowing`所声明的新变量，其类型可以与原先不一致。
例如：
```Rust
    let spaces = "   ";
    let spaces = spaces.len();
```
```Rust
    let mut spaces = "   ";
    spaces = spaces.len();
```
上面这段代码可以通过编译；而下面这段代码则会报错。
### 数据类型
Rust的基础数据类型可分为：**标量**`scalar`和**复合**`compound`
#### 标量
**标量**类型表示一个单独的值，Rust共有四种基本的标量类型：**整数**、**浮点型**、**布尔类型**和**字符类型**。
##### 整型
与C语言中的`int`,`short`,`long`,`uintxx_t`相对应，存储有符号整数或者无符号整数。
为指定类型则默认为`i32`。
```Rust
let a: i8 = 255;
let b = 254;
```

| 长度      | 有符号     | 无符号     |
| ------- | ------- | ------- |
| 8-bit   | `i8`    | `u8`    |
| 16-bit  | `i16`   | `u16`   |
| 32-bit  | `i32`   | `u32`   |
| 64-bit  | `i64`   | `u64`   |
| 128-bit | `i128`  | `u128`  |
| arch    | `isize` | `usize` |

其中`isize`与`usize`与机器字长有关，在32位机器上为32bit,64位机器上为64bit。
Rust在处理整型溢出时，如果是`debug`模式下构建发生溢出，则会`panic`；如果为`--release`在release模式下构建，Rust不会检查整型溢出，而是采用二进制补码wrapping(two's complement wrapping)操作。
>在 Rust 中，`two's complement wrapping` 是指当整数运算导致溢出时，结果会按照二进制补码的方式进行环绕处理。具体来说，当一个整数超出其表示范围时，它会从另一端重新开始。例如，对于一个 8 位的无符号整数（`u8`），其范围是 0 到 255。如果我们对 255 加 1，结果会变成 0。

如果需要显式处理溢出，可以使用标准库提供的原始数字类型方法：
- 所有模式下都可以使用 `wrapping_*` 方法进行 wrapping，如 `wrapping_add`
- 如果 `checked_*` 方法出现溢出，则返回 `None`值
- 用 `overflowing_*` 方法返回值和一个布尔值，表示是否出现溢出
- 用 `saturating_*` 方法在值的最小值或最大值处进行饱和处理

##### 浮点型
Rust中浮点型分为`f32`与`f64`，分别占32位和64位。
未制定字面量所对应的类型时，默认为`f64`。
```Rust
let a: f32 = 1.234;
let b = 3.1414;
```
##### 布尔型
Rust中布尔型采用`bool`表示，值为`true`或`false`。
##### 字符类型
Rust中字符类型采用`char`表示。
与C一样使用单引号表示字符字面量，使用双引号表示字符串字面量。
Rust中的`char`大小为四字节，表示一个Unicode字符值。
#### 复合类型
复合类型将多个值组合成一个类型。
Rust的原生复合类型有：**元组(tuple)** 和**数组(array)**。
##### 元组
`tuple`可以将多个不同类型的值进行组合。
与python中的元组一样，Rust中的`tuple`长度在声明后是固定的，其长度不会增大或缩小。
Rust中元组声明使用`()`包裹元素，当没有类型注解时，会自动推导元素类型。
使用“`.`+ 索引”的方式访问元组中的元素。
```Rust
fn main() {
    let tup = (12, 4, 5.12);

    println!("The value of tup.0 is: {}", tup.0);
}
```
使用类型注解声明元素类型：
```Rust
let x: (i32, f64, u8) = (500, 6.4, 1);
```
可以使用解构将元组中的值保存至新的变量中：
```Rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
```
不带任何元素的元组被叫做**单元(unit)元组**，写作`()`，表示空值或空的返回类型。
如果表达式不返回值，则会隐式返回`()`。
##### 数组
数组中每个元素类型必须相同。
Rust中数组长度固定。
声明方式：
```rust
let a = [1, 2, 3, 4, 5];
let b: [i32; 5] = [1, 2, 3, 4, 5]; // 使用类型注解
let c = [3; 5]; // 声明一个全为3,长度为5的数组
```
数组元素的访问方式为`a[index]`；在数组下标越界时，Rust会直接panic。
### 函数
Rust中的函数使用`fn`关键字声明，函数名和变量名采用`snake_case`风格，即所有字母都是小写并使用下划线分隔单词。
Rust不关心函数定义所在位置，只要函数被调用时出现在调用处可见的作用域内即可。
```rust
fn main() {
    println!("main function.");

    another_function(114514);
}

fn another_function(x: i32) {
    println!("Another function x = {x}.");
}
```
Rust函数的形参必须书写类型注解。
#### 语句与表达式
与其他语言不同，Rust区分语句与表达式。
以`;`结尾的为语句，语句没有返回值；
结尾无`;`的为表达式，表达式有返回值。
声明变量为变量绑定值的式子为语句，如`let x = 12;`。
例如：
```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {y}");
}
```
其中：
```rust
{
	let x = 3;
	x + 1
}
```
这个代码块是一个表达式，它的值为表达式`x + 1`的值，即为4。
#### 返回值
声明一个具有返回值的函数，只需在箭头(`->`)后声明它的返回值类型即可。
在Rust中，函数返回值隐式等于最后一个表达式的值。
当然，也可以使用`return`关键字指定值提前返回。
```rust
fn add(x: i32, y: i32) -> i32 {
	x + y
}

fn main() {
	let x = add(12, 18);
	println!("x = {x}");
}
```
