### 预处理符号

| 符号         | 示例值           | 含义                           |
| ---------- | ------------- | ---------------------------- |
| `__FILE__` | `name.c`      | 进行编译的源文件名                    |
| `__LINE__` | `24`          | 文件当前行的行号                     |
| `__DATE__` | `Jan 21 2023` | 文件被编译的日期                     |
| `__TIME__` | `21:23:10`    | 文件被编译的时间                     |
| `__STDC__` | `1`           | 文件是否遵循`ANSI C`标准，`1`表示`true` |
### \#define
**e.g.**
`#define name stuff`

每当符号`name`出现时，预处理器将其替换为`stuff`。
如果定义中的`stuff`过长，则可将其分为多行，并在除最后一行外的所有行的末尾加上`\`
```c
#define u8 uint8_t
#define DEBUG_PRINT    printf("File %s line %d: " \
							" x = %d, y = %d, z = %d", \
							__FILE__, __LINE__, \
							x, y, z)

if(...)
	DEBUG_PRINT;
```
相邻的字符串常量会被自动连接为一个字符串。
#### 宏
`#define`允许将参数替换至文本中，这一机制称为宏(`macro`)或定义宏(`defined macro`)，声明方式为：
`#define name(parameter-list) stuff`
`parameter-list`为一个由`,`分隔的符号列表，参数列表左侧与`(`间不能有`<space>`；
当宏被调用时，参数列表中的值会与`stuff`中对应的值进行一一替换。
宏与参数的类型无关，只要对于参数的操作是合法的，它可以用于任何参数类型。
**e.g.**
```c
#define SQUARE(X) X * X

int a = SQUARE(5); // equal to `int a = 5 * 5`
```
如果想将宏参数插入字符串常量中：
1. 宏参数为字符串时，使用字符串拼接
```c
#define PRINT(FORMAT, VALUE)    \
		printf("The value is" FORMAT "\n", VALUE)
...
PRINT("%d", x + 3); // printf("The value is%d\n", x + 3)
```
2. 使用`#`将宏参数转换为一个字符串
```c
#define PRINT(FORMAT, VALUE)    \
		printf("The value of " #VALUE " is " FORMAT "\n", VALUE)
...
PRINT("%d", x + 3); // printf("The value of x + 3 is %d\n", x + 3)
```
3. 使用`##`将变量与字符串连接
```c
#define ADD_TO_SUM(sum_number, value)    \
		sum ## sum_number += value
...
ADD_TO_SUM(5, 25); // sum5 += 25
```
#### \#undef
当需要重定义一个已经存在的宏时，需要先使用`#undef`移除原有宏。
```c
#define MAX(a, b) ((a > b)? (a) : (b))
#undef MAX
```
#### 命令行定义
在命令行使用c编译器时，可以启用定义符号，如
```c
// example.c
int array[ARRAY_SIZE]
```
```shell
gcc -E example.c -DARRAY_SIZE=100 -o example.i
```
`example.i` :
```
# 0 "example.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "example.c"

int array[100];

```
> 宏是在预处理时进行替换，会使程序的长度增加。
> 就执行速度而言，宏比函数要快，因为函数存在调用与返回时的额外开销
### 条件编译
条件编译(`conditional compilation`)可以根据条件是否满足，从而决定是否编译某一部分代码。
语法格式：
```c
#if constant-expression
	statements
#elif constant-expression
	statements
#else
	statements
#endif
```
其中
`constant-expression`，即常量表达式，需要可被预处理器求值，如果变量在执行期前无法获得其值，则常量表达式非法。简单来说，常量表达式的值在编译期间必须可以预测。
`elif`与`else`为可选的。
#### \#ifdef
如果需要判断一个符号是否被定义，有以下两种方法，它们是等价的：
```c
#if defined(symbol)
	...
#endif
#ifdef symbol
	...
#endif

#if !defined(symbol)
	...
#endif
#ifndef symbol
	...
#endif
```
**e.g.**
```c
// test.c
#define A 10
#ifdef A
	int a;
#endif
#if defined(A)
	int aa;
#endif
#ifndef B
	int b;
#endif
#if !defined(B)
	int bb;
#endif
```
`test.i`:
```
# 0 "test.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "test.c"


 int a;


 int aa;


 int b;


 int bb;
```
`#ifdef`与`ifndef`同样能与`#elif`或`#else`组合使用。

借助条件编译，可以解决嵌套头文件包含的问题。
### 文件包含
##### 函数库文件包含
```c
#include <stdio.h>
```
标准函数库头文件以`.h`结尾，编译器在一系列**标准位置**寻找这些文件，在Linux下，这个标准位置为`/usr/include`。
也可以通过命令行选项将某个目录添加到这个列表中，以gcc为例：
```shell
gcc -I/path/to/your/include -o your_program your_program.c
```
##### 本地文件包含
```c
#include "filename"
```
当使用`""`包裹头文件时，处理本地头文件的策略为：
1. 先在源文件所在目录下查找;
2. 若源文件目录下未找到，则在查找函数库文件的**标准位置**进行查找。

`filename`也可以是指示头文件所在位置的*绝对路径*。
文件包含相比函数库文件包含，要多一些额外开销。
##### 嵌套文件包含
考虑如下代码：
```c
#include "a.h"
#include "b.h"
```
如果`a.h`与`b.h`中均包含`#include "x.h"`，那么`x.h`在这里就被包含了两次。
要解决这个嵌套包含的问题，可以采用如下编写头文件的方式：
```c
#ifndef _HEADERNAME_H
#define _HEADERNAME_H 1
/*
** All the stuff that you want in the header file.
*/
#endif
```
当头文件第一次被包含时，条件编译通过，头文件被展开；
当头文件再次被包含时，条件编译不通过，头文件被忽略，成功避免了嵌套头文件包含。
其中`#define _HEADERNAME_H 1`可替换为`#define _HEADERNAME_H`。
尽管这样避免了嵌套包含，但即使条件编译不通过，预处理器依然要读入整个头文件，这也会拖慢编译速度，所以应该尽可能避免出现多重包含。